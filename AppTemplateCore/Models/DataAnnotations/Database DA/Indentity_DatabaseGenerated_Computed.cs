using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Threading.Tasks;

namespace AppTemplateCore.Models.DataAnnotations.Database_DA
{
    //Data Annotations - DatabaseGenerated Attribute in EF 6 & EF Core

    //As you know, EF creates an IDENTITY column in the database for all the id(key) properties 
    //of the entity, by default. 
    //So, the underlying database generates a value for this column on each insert command, 
    //e.g., SQL Server creates an integer IDENTITY column with identity seed and increment to 1.

    //EF 6 and EF Core provide the DatabaseGenerated data annotation attribute 
    //to configure how the value of a property will be generated. 
    // CONFIQURE HOW THE VALUE OF THE PROPERTY WILL BE GENERATED.

    //The DatabaseGenerated attribute takes one out of the following three 
    //DatabaseGeneratedOption enum values :

    //DatabaseGeneratedOption.None
    //DatabaseGeneratedOption.Identity
    //DatabaseGeneratedOption.Computed

    //DatabaseGeneratedOption.Compute
    //DatabaseGeneratedOption.Compute specifies that the value of the property will be generated by 
    //the underlying database on insert and then, on each subsequent update.

    //Same as Identity, the way the database generates the value depends on the database provider. 
    //You may configure a default value or use a trigger for this computed column.

    //Consider the following example.

    public class Student65478
    {
        public int StudentID { get; set; }
        public string StudentName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public decimal Height { get; set; }
        public float Weight { get; set; }

        [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
        public DateTime CreatedDate { get; set; }
    }


    // In the above example, the CreatedDate property is marked with the DatabaseGeneratedOption.Computed 
    //option.

    //This tells EF that values are generated for this column in the database.

    //However, EF does not guarantee that it will setup the actual mechanism to generate values. 

    //Here, we will specify date function of SQL Server which will generate current date-time value 
    //on INSERT command, as shown below.

    //protected override void OnModelCreating(ModelBuilder modelBuilder)
    //{

    //    modelBuilder.Entity<Student>()
    //            .Property(s => s.CreatedDate)
    //            .HasDefaultValueSql("GETDATE()");
    //}


    //The above code set the SQL Server function GETDATE() as a default value SQL which will insert 
    //the current date and time on each INSERT command.

    //Note: EF does not include DatabaseGeneratedOption.Computed columns in 
    //INSERT or UPDATE statements.

    //DatabaseGenerated.Computed
    //This is useful in scenarios where you have COMPUTED COLUMNS in your database.
    //The Database computes the value of these fields after each insert/update operation. 
    //The entity framework will not update these columns. 
    //But it will query and return the values of these fields after an insert or update operation.


    public class CustomerWWWWWWWWWWWWWWWWWW
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.None)]
        public int CustomerID { get; set; }

        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int SrNo { get; set; }
        public string Test { get; set; }

        [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
        public string CustomerName { get; set; }

        [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
        public DateTime? Created { get; set; } = DateTime.UtcNow;

    }

    //In the above model, we have two computed fields.CustomerName & Created.
    //Use the following code to insert data into the table. 
    //Both customerName & created fields are given value.

    // EFContext ctx = new EFContext();
    // ctx.ConfigureLogging(s => Console.WriteLine(s)); 
    //var c = new Customer();
    // c.Test = "Test";
    //c.CustomerName = "Test";
    //c.Created = Convert.ToDateTime("2018-01-01");
    //ctx.Customer.Add(c);
    //ctx.SaveChanges();

    //The FE generates the following SQL statement.As you can see the EF does not insert the values 
    //to the customerName  & Created fields, but it tries to retrieve the value of these 
    //fields immediately after the insert.i.e.because EF expects that the database to 
    //compute the value of these fields.

    //INSERT INTO[Customer] ([CustomerID], [Test])
    //VALUES(@p0, @p1);

    //SELECT[Created], [CustomerName], [SrNo]
    //FROM[Customer]
    //WHERE @@ROWCOUNT = 1 AND[CustomerID] = @p0;

    //Similarly, the update query does not update the computed fields but retrieves them after the 
    //update expecting that the database may have computed and updated these fields

    //UPDATE[Customer] SET[Test] = @p0
    //WHERE[CustomerID] = @p1;

    //SELECT[Created], [CustomerName]
    //FROM[Customer]
    //WHERE @@ROWCOUNT = 1 AND[CustomerID] = @p1;

    //In both, the above examples, the database inserts the null value into the CustomerName & 
    //Created fields as we are not generating any values for them in the database.
    //For testing purposes, you can use the following insert trigger to insert values and 
    //check the result.

    //CREATE TRIGGER insTrigger
//ON dbo.Customer
//AFTER INSERT AS
//BEGIN
   //update Customer
   //set customerName='Default Customer Name', created=GETDATE()
   // inserted
   //where Customer.CustomerID=inserted.CustomerID;

    //END
    //GO




}
